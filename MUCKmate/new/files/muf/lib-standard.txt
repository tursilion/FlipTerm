@prog lib-standard.karna
1 9999999 d
1 i
( ***********************************************************************************
Lib-Standard is a library of commonly used primitives to make MUF-programming easier.
Primarily made for use by .karna programs, but useful for others none the less.
*********************************************************************************** )


( ********************************* ATTENTION ************************************* )
$def sexprop "~sex" (*** CHANGE THIS TO THE PROPERTY CHARACTER SEXES ARE STORED IN. ***)
$def speciesprop "~species" (*** CHANGE THIS TO THE PROPERTY CHARACTER SPECIES ARE STORED IN. ***)
( ********************************************************************************* )

: intotimestr
       dup 86400 > if 86400 / intostr "d" strcat else   
       dup 3600 > if 3600 / intostr "h" strcat else   
       dup 60 > if 60 / intostr "m" strcat else    
     intostr "s" strcat
 then then then
;
: clean_descriptors
 dup player? not if owner then

 descriptors dup 1 = if pop else
             dup 2 = if pop pop else
             dup 3 = if pop pop pop else
             dup 4 = if pop pop pop pop else
             dup 5 = if pop pop pop pop pop else
             dup 6 = if pop pop pop pop pop pop else
             pop 7 = if pop pop pop pop pop pop pop else
                        pop pop pop pop pop pop pop pop
             then then then then then then then
;
: returnIdleTime
 dup awake? not if pop "~&110[~&160---~&110]" exit then
 clean_descriptors
 descrcon conidle intotimestr
 dup strlen 2 = if " " strcat then
 "~&110[~&160" swap strcat "~&110]" strcat
;

: pmatch ( s -- d )
( pmatch returns the DBREF of any player, regardless of location.)
( In the event that the player does not exist, #-1 is returned. )
( 'here' and 'me' work as expected. )
( If no name is provided, #-1 is returned. )
( If the argument is not a string, #-1 is returned. )
( If the argument is ambiguous, #-2 is returned. )
dup not if #-1 exit then
dup string? not if #-1 exit then
dup "me" stringcmp not if match exit then
dup "here" stringcmp not if match exit then
"*" swap strcat match
; 

: get_sex ( x -- s )
( get_sex returns the sex of a character or object in the form of a STRING. )
( get_sex can take either a STRING or a DBREF as an argument. )
( get_sex will return "*UNKNOWN*" if no argument is provided. )
dup not if pop "*UNKNOWN*" exit then
dup string? if 
     pmatch 
     dup #-1 dbcmp if pop "*UNKNOWN*" exit then
     dup #-2 dbcmp if pop "*UNKNOWN*" exit then
then sexprop getpropstr
;

: wizard? ( d -- i )
( wizard? returns 1 if the object is set Wizard, 0 if not, and #-1 if no DBREF was provided.)
( Returns #-1 if the argument is not a DBREF. )
dup dbref? not if pop #-1 exit then
dup not if pop #-1 exit then "wizard" flag?
;

: npc? ( d -- i )
( npc? returns 1 if the object is an NPC, 0 if not, and #-1 if no DBREF was provided.)
( Returns #-1 if the argument is not a DBREF. )
dup dbref? not if pop #-1 exit then
dup not if pop #-1 exit then "~npc" getpropstr if 1 else 0 then
;

: zombie? ( d -- i )
( zombie? returns 1 if the object is a Zombie, 0 if not, and #-1 if no DBREF was provided.)
( Returns #-1 if the argument is not a DBREF. )
dup dbref? not if pop #-1 exit then
dup not if pop #-1 exit then "Z" flag?
;

: male? ( d -- i )
( male? returns 1 if the object is a male, 0 if not, and #-1 if no DBREF was provided.)
( Returns #-1 if the argument is not a DBREF. )
dup dbref? not if pop #-1 exit then
dup not if pop #-1 exit then get_sex "male" stringcmp not if 1 else 0 then
;

: female? ( d -- i )
( female? returns 1 if the object is a female, 0 if not, and #-1 if no DBREF was provided.)
( Returns #-1 if the argument is not a DBREF. )
dup dbref? not if pop #-1 exit then
dup not if pop #-1 exit then get_sex "female" stringcmp not if 1 else 0 then
;

: truewizard? ( d -- i )
( truewizard? returns 1 if the object is set Wizard, regardless if the target is set QUELL or not. )
( truewizard? will return 0 if the object has no W flag, and #-1 if no DBREF was provided.)
( Returns #-1 if the argument is not a DBREF. )
dup dbref? not if pop #-1 exit then
dup not if pop #-1 exit then "truewizard" flag?
;

: dtoa ( d -- s )
( dtoa turns DBREF d into STRING s )
( If no DBREF is provided, dtoa returns "#-1" )
( If argument is not provided, dtoa returns "#-1" )
dup not if pop "#-1" exit then
dup dbref? not if pop "#-1" exit then
intostr "#" swap strcat
;

: pmatch_s ( s -- s )
( pmatch_s returns the DBREF of any player as a string, regardless of location. )
( In the event that the player does not exist, "*UNKNOWN*" is returned. )
( If no name is provided, "*UNKNOWN*" is returned. )
( If the argument is not a string, "*UNKNOWN*" is returned. )
( If the argument is ambiguous, "*UNKNOWN*" is returned. )
dup not if pop "*UNKNOWN*" exit then
dup string? not if pop "*UNKNOWN*" exit then
"*" swap strcat match
dup #-2 dbcmp if "*UNKNOWN*" exit then
dtoa
;

: name_d ( d -- s )
( name_d returns a player's name, followed by a space and their DBREF in string form. )
( In the event that the dbref given does not exist, "*UNKNOWN*" is returned. )
( If no DBREF is provided, "*UNKNOWN*" is returned. )
( If the argument is not a DBREF, "*UNKNOWN*" is returned. )
dup not if "*UNKNOWN*" exit then
dup dbref? not if "*UNKNOWN*" exit then
dup ok? not if "*UNKNOWN*" exit then
unparseobj 
" " "(" subst
" " ")" subst
;

: parse_mpi ( s -- s )
( parse_mpi will parse a string of MPI code. )
( parse_mpi returns a NULL string if no argument is provided, or the argument isn't a string.)
dup not if pop "" exit then
dup string? not if pop "" exit then
me @ swap "/@/tmp" swap setprop
me @ "/@/tmp" "($lib/std-karna.PARSE_MPI)" 0 parseprop
me @ "/@/tmp" remove_prop
;

: ucfirst ( s -- s )
( ucfirst will capitalize the first letter of a string.)
( ucfirst returns a NULL string if no argument is provided, or the argument isn't a string.)
dup not if pop "" exit then
dup string? not if pop "" exit then
1 strcut swap toupper swap strcat
;

: lcfirst ( s -- s )
( lcfirst will lowercase the first letter of a string.)
( lcfirst returns a NULL string if no argument is provided, or the argument isn't a string.)
dup not if pop "" exit then
dup string? not if pop "" exit then
1 strcut swap tolower swap strcat
;

: uclast ( s -- s )
( uclast will capitalize all letters in a string except the first. )
( uclast returns a NULL string if no argument is provided, or the argument isn't a string.)
dup not if pop "" exit then
dup string? not if pop "" exit then
1 strcut toupper strcat
;

: lclast ( s -- s )
( lclast will lowercase all letters in a string except the first. )
( lclast returns a NULL string if no argument is provided, or the argument isn't a string.)
dup not if pop "" exit then
dup string? not if pop "" exit then
1 strcut tolower strcat
;

PUBLIC pmatch
PUBLIC get_sex
PUBLIC ucfirst
PUBLIC uclast
PUBLIC lcfirst
PUBLIC lclast
PUBLIC parse_mpi
PUBLIC pmatch_s
PUBLIC name_d
PUBLIC dtoa
PUBLIC male?
PUBLIC female?
PUBLIC truewizard?
PUBLIC zombie?
PUBLIC npc?
PUBLIC wizard?
PUBLIC returnIdleTime
PUBLIC clean_descriptors
.
c
q
@set lib-standard.karna=_defs/get_sex:"$lib/standard" match "get_sex" call

@set lib-standard.karna=_defs/ucfirst:"$lib/standard" match "ucfirst" call
@set lib-standard.karna=_defs/uclast:"$lib/standard" match "uclast" call
@set lib-standard.karna=_defs/lcfirst:"$lib/standard" match "lcfirst" call
@set lib-standard.karna=_defs/lclast:"$lib/standard" match "lclast" call

@set lib-standard.karna=_defs/parse_mpi:"$lib/standard" match "parse_mpi" call

@set lib-standard.karna=_defs/pmatch_s:"$lib/standard" match "pmatch_s" call
@set lib-standard.karna=_defs/name_d:"$lib/standard" match "name_d" call
@set lib-standard.karna=_defs/dtoa:"$lib/standard" match "dtoa" call

@set lib-standard.karna=_defs/male?:"$lib/standard" match "male?" call
@set lib-standard.karna=_defs/female?:"$lib/standard" match "female?" call
@set lib-standard.karna=_defs/truewizard?:"$lib/standard" match "truewizard?" call
@set lib-standard.karna=_defs/zombie?:"$lib/standard" match "zombie?" call
@set lib-standard.karna=_defs/npc?:"$lib/standard" match "npc?" call
@set lib-standard.karna=_defs/wizard?:"$lib/standard" match "wizard?" call

@set lib-standard.karna=_defs/returnIdleTime:"$lib/standard" match "returnIdleTime" call
@set lib-standard.karna=_defs/clean_descriptors:"$lib/standard" match "clean_descriptors" call

@set lib-standard.karna=L
@register lib-standard.karna=lib/standard

